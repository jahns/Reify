<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>F.4. VK_KHR_display</title><link rel="stylesheet" type="text/css" href="config/vkspec-xhtml.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Vulkan 1.0.21 + WSI Extensions - A Specification" /><link rel="up" href="apf.html" title="Appendix F. Window System Integration (WSI) Extensions" /><link rel="prev" href="apfs03.html" title="F.3. VK_KHR_swapchain" /><link rel="next" href="apfs05.html" title="F.5. VK_KHR_display_swapchain" /><script xmlns="" type="text/x-mathjax-config">
        MathJax.Hub.Config({
            MathML: { extensions: ["content-mathml.js"] },
            tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] }
        });
    </script><script xmlns="" type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="apfs03.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="apfs05.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_vk_khr_display"></a>F.4. VK_KHR_display</h2></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>Name String</strong></span>
</span></dt><dd>
vk_khr_display
</dd><dt><span class="term">
<span class="strong"><strong>Extension Type</strong></span>
</span></dt><dd>
Instance extension
</dd><dt><span class="term">
<span class="strong"><strong>Registered Extension Number</strong></span>
</span></dt><dd>
3
</dd><dt><span class="term">
<span class="strong"><strong>Status</strong></span>
</span></dt><dd>
Draft.
</dd><dt><span class="term">
<span class="strong"><strong>Last Modified Date</strong></span>
</span></dt><dd>
11/10/2015
</dd><dt><span class="term">
<span class="strong"><strong>Revision</strong></span>
</span></dt><dd>
21
</dd><dt><span class="term">
<span class="strong"><strong>IP Status</strong></span>
</span></dt><dd>
No known IP claims.
</dd><dt><span class="term">
<span class="strong"><strong>Dependencies</strong></span>
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
This extension is written against revision 1.0 of the Vulkan API.
</li><li class="listitem">
This extension requires VK_KHR_surface.
</li></ul></div></dd><dt><span class="term">
<span class="strong"><strong>Contributors</strong></span>
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
James Jones, NVIDIA
</li><li class="listitem">
Norbert Nopper, Freescale
</li><li class="listitem">
Jeff Vigil, Qualcomm
</li><li class="listitem">
Daniel Rakos, AMD
</li></ul></div></dd><dt><span class="term">
<span class="strong"><strong>Contacts</strong></span>
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
James Jones (jajones <span class="emphasis"><em>at</em></span> nvidia.com)
</li><li class="listitem">
Norbert Nopper (Norbert.Nopper <span class="emphasis"><em>at</em></span> freescale.com)
</li></ul></div></dd></dl></div><p>This extension provides the API to enumerate displays and available
modes on a given device.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_new_object_types_3"></a>F.4.1. New Object Types</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="code">VkDisplayKHR</code>
</li><li class="listitem">
<code class="code">VkDisplayModeKHR</code>
</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_new_enum_constants_4"></a>F.4.2. New Enum Constants</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">
Extending <code class="code">VkStructureType</code>:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
<code class="code">VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR</code>
</li><li class="listitem">
<code class="code">VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR</code>
</li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_new_enums_3"></a>F.4.3. New Enums</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="code">VkDisplayPlaneAlphaFlagBitsKHR</code>
</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_new_structures_3"></a>F.4.4. New Structures</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="code"><a class="link" href="ch29s03.html#VkDisplayPropertiesKHR">VkDisplayPropertiesKHR</a></code>
</li><li class="listitem">
<code class="code"><a class="link" href="ch29s03.html#VkDisplayModeParametersKHR">VkDisplayModeParametersKHR</a></code>
</li><li class="listitem">
<code class="code"><a class="link" href="ch29s03.html#VkDisplayModePropertiesKHR">VkDisplayModePropertiesKHR</a></code>
</li><li class="listitem">
<code class="code"><a class="link" href="ch29s03.html#VkDisplayModeCreateInfoKHR">VkDisplayModeCreateInfoKHR</a></code>
</li><li class="listitem">
<code class="code"><a class="link" href="ch29s03.html#VkDisplayPlanePropertiesKHR">VkDisplayPlanePropertiesKHR</a></code>
</li><li class="listitem">
<code class="code"><a class="link" href="ch29s03.html#VkDisplayPlaneCapabilitiesKHR">VkDisplayPlaneCapabilitiesKHR</a></code>
</li><li class="listitem">
<code class="code"><a class="link" href="ch29s03.html#VkDisplaySurfaceCreateInfoKHR">VkDisplaySurfaceCreateInfoKHR</a></code>
</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_new_functions_3"></a>F.4.5. New Functions</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="code"><a class="link" href="ch29s03.html#vkGetPhysicalDeviceDisplayPropertiesKHR">vkGetPhysicalDeviceDisplayPropertiesKHR</a></code>
</li><li class="listitem">
<code class="code"><a class="link" href="ch29s03.html#vkGetPhysicalDeviceDisplayPlanePropertiesKHR">vkGetPhysicalDeviceDisplayPlanePropertiesKHR</a></code>
</li><li class="listitem">
<code class="code"><a class="link" href="ch29s03.html#vkGetDisplayPlaneSupportedDisplaysKHR">vkGetDisplayPlaneSupportedDisplaysKHR</a></code>
</li><li class="listitem">
<code class="code"><a class="link" href="ch29s03.html#vkGetDisplayModePropertiesKHR">vkGetDisplayModePropertiesKHR</a></code>
</li><li class="listitem">
<code class="code"><a class="link" href="ch29s03.html#vkCreateDisplayModeKHR">vkCreateDisplayModeKHR</a></code>
</li><li class="listitem">
<code class="code"><a class="link" href="ch29s03.html#vkGetDisplayPlaneCapabilitiesKHR">vkGetDisplayPlaneCapabilitiesKHR</a></code>
</li><li class="listitem">
<code class="code"><a class="link" href="ch29s03.html#vkCreateDisplayPlaneSurfaceKHR">vkCreateDisplayPlaneSurfaceKHR</a></code>
</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_issues_3"></a>F.4.6. Issues</h3></div></div></div><p>1)  Which properties of a mode should be fixed in the mode info Vs.
    settable in some other function when setting the mode?  E.g., do
    we need to double the size of the mode pool to include both stereo
    and non-stereo modes?  YUV and RGB scannout even if they both take
    RGB input images?   BGR Vs. RGB input?   etc.</p><pre class="literallayout">PROPOSED RESOLUTION: Many modern displays support at most
a handful of resolutions and timings natively.  Other "modes" are
expected to be supported using scaling hardware on the display engine
or GPU.  Other properties, such as rotation and mirroring shouldn't
require duplicating hardware modes just to express all combinations.
Further, these properties may be implemented on a per-display or per-
overlay granularity.</pre><pre class="literallayout">To avoid the exponential growth of modes as mutable properties are
added, as was the case with EGLConfig/WGL pixel formats/GLXFBConfig,
this specificaiton should separate out hardware properties and
configurable state into separate objects.  Modes and overlay planes
will express capabilities of the hardware, while a separate structure
will allow applications to configure scaling, rotation, mirroring,
color keys, LUT values, alpha masks, etc. for a given swapchain
independent of the mode in use.  Constraints on these settings will
be established by properties of the immutable objects.</pre><pre class="literallayout">Note the resolution of this issue may affect issue (5) as well.</pre><p>2)  What properties of a display itself are useful?</p><pre class="literallayout">PROPOSED RESOLUTION: This issue is too broad.  It was meant to
prompt general discussion, but resolving this issue amounts to
completing this specification.  All interesting properties should
be included.  The issue will remain as a placeholder since
removing it would make it hard to parse existing discussion notes
that refer to issues by number.</pre><p>3)  How are multiple overlay planes within a display or mode enumerated?</p><pre class="literallayout">PROPOSED RESOLUTION: They are refered to by an index.  Each display
will report the number of overlay planes it contains.</pre><p>4)  Should swapchains be created relative to a mode or a display?</p><pre class="literallayout">PROPOSED RESOLUTION: When using this extension, swapchains are
created relative to a mode and a plane.  The mode implies the display
object the swapchain will present to.  If the specified mode is not
the display's current mode, the new mode will be applied when the
first image is presented to the swapchain, and the default operating
system mode, if any, will be restored when the swapchain is destroyed.</pre><p>5)  Should users query generic ranges from displays and construct
    their own modes explicitly using those constraints rather than
    querying a fixed set of modes (Most monitors only have one real
    "mode" these days, even though many support relatively arbitrary
    scaling, either on the monitor side or in the GPU display engine,
    making "modes" something of a relic/compatibility construct).</p><pre class="literallayout">PROPOSED RESOLUTION: Expose both.  Display info structures will
expose a set of predefined modes, as well as any attributes
necessary to construct a customized mode.</pre><p>6)  Is it fine if we return the display and display mode handles in the
    structure used to query their properties?</p><pre class="literallayout">PROPOSED RESOLUTION: Yes.</pre><p>7)  Is there a possibility that not all displays of a device work with
    all of the present queues of a device? If yes, how do we determine
    which displays work with which present queues?</p><pre class="literallayout">PROPOSED RESOLUTION: No known hardware has such limitations, but
determing such limitations is supported automatically using the
existing VK_EXT_KHR_surface and VK_EXT_KHR_swapchain query mechanisms.</pre><p>8)  Should all presentation need to be done relative to an overlay plane,
    or can a display mode + display be used alone to target an output?</p><pre class="literallayout">PROPOSED RESOLUTION: Require specifying a plane explicitly.</pre><p>9)  Should displays have an associated window system display, such as an
    HDC or Display*?</p><pre class="literallayout">PROPOSED RESOLUTION: No.  Displays are independent of any windowing
system in use on the system.  Further, neither HDC nor Display* refer
to a physical display object.</pre><p>10) Are displays queried from a physical GPU or from a device instance?</p><pre class="literallayout">PROPOSED RESOLUTION: Developers prefer to query modes directly from
the physical GPU so they can use display information as an input
to their device selection algorithms prior to device creation.  This
avoids the need to create dummy device instances to enumerate
displays.</pre><pre class="literallayout">This preference must be weighed against the extra initializaiton
that must be done by driver vendors prior to device instance
creation to support this usage.</pre><p>11) Should displays and/or modes be dispatchable objects?
    If functions are to take displays, overlays, or modes as their
    first parameter, they must be dispatchable objects as defined
    in Khronos bug 13529.  If they aren’t added to the list of
    dispatchable objects, functions operating on them must take some
    higher-level object as their first parameter.  There is no
    performance case against making them dispatchable objects, but
    they would be the first extension objects to be dispatchable.</p><pre class="literallayout">PROPOSED RESOLUTION: Do not make displays or modes dispatchable.
They will dispatch based on their associated physical device.</pre><p>12) Should hardware cursor capabilities be exposed?</p><pre class="literallayout">PROPOSED RESOLUTION: Defer.  This could be a separate extension on
top of the base WSI specs.</pre><pre class="literallayout">if they are one physical display device to an end user, but may
internally be implemented as two side-by-side displays using the
same display engine (and sometimes cabling) resources as two
physically separate display devices.</pre><pre class="literallayout">PROPOSED RESOLUTION: Tiled displays will appear as a single display
object in this API.</pre><p>14) Should the raw EDID data be included in the display information?</p><pre class="literallayout">PROPOSED RESOLUTION: None.  Unclear whether this is a good idea.
Provides a path for forward-compatibility as new EDID extensions
are introduced, but may be complicated by the outcome of issue 13.</pre><p>15) Should min and max scaling factor capabilities of overlays be
    exposed?</p><pre class="literallayout">PROPOSED RESOLUTION: Yes.  This is exposed indirectly by allowing
applications to query the min/max position and extent of the source
and destination regions from which image contents are fetched by
the display engine when using a particular mode and overlay pair.</pre><p>16) Should devices be able to expose planes that can be moved between
    displays?  If so, how?</p><pre class="literallayout">PROPOSED RESOLUTION: None.</pre><p>17) Should there be a way to destroy display modes?  If so, does it
    support destroying "built in" modes?</p><pre class="literallayout">PROPOSED RESOLUTION: None.</pre><p>18) What should the lifetime of display and built-in display mode objects
    be?</p><pre class="literallayout">PROPOSED RESOLUTION: The lifetime of the instance.  These objects can
not be destroyed.  A future extension may be added to expose a way to
destroy these objects and/or support display hotplug.</pre><p>19) Should persistent mode for smart panels be enabled/disabled at swap
    chain creation time, or on a per-present basis.</p><pre class="literallayout">PROPOSED RESOLUTION: On a per-present basis.</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_examples_3"></a>F.4.7. Examples</h3></div></div></div><p><span class="strong"><strong>Example 1</strong></span></p><p>Enumerating displays, display modes, and planes, and creating a VkSurfaceKHR</p><pre class="programlisting">    extern VkBool32 ModeMatchesMyCriteria(const VkDisplayModePropertiesKHR *m);
    extern VkInstance instance;
    extern VkPhysicalDevice physDevice;
    extern VkSurfaceKHR surface;

    uint32_t displayCount, planeCount, i, j, k;
    VkDisplayPropertiesKHR* pDisplayProps;
    VkDisplayPlanePropertiesKHR* pPlaneProps;
    VkDisplayModeKHR myMode = VK_NULL_HANDLE;
    VkDisplayKHR myDisplay = VK_NULL_HANDLE;
    uint32_t bestPlane = UINT32_MAX;
    VkDisplayPlaneAlphaFlagBitsKHR alphaMode = 0;
    PFN_vkGetPhysicalDeviceDisplayPropertiesKHR pfnGetPhysicalDeviceDisplayPropertiesKHR;
    PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR pfnGetPhysicalDeviceDisplayPlanePropertiesKHR;
    PFN_vkGetDisplayModePropertiesKHR pfnGetDisplayModePropertiesKHR;
    PFN_vkGetDisplayPlaneCapabilitiesKHR pfnGetDisplayPlaneCapabilitiesKHR;
    PFN_vkGetDisplayPlaneSupportedDisplaysKHR pfnGetDisplayPlaneSupportedDisplaysKHR;
    PFN_vkCreateDisplayPlaneSurfaceKHR pfnCreateDisplayPlaneSurfaceKHR;

    pfnGetPhysicalDeviceDisplayPropertiesKHR =
        (PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)
        vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPropertiesKHR");
    pfnGetPhysicalDeviceDisplayPlanePropertiesKHR =
        (PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)
        vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
    pfnGetDisplayModePropertiesKHR =
        (PFN_vkGetDisplayModePropertiesKHR)
        vkGetInstanceProcAddr(instance, "vkGetDisplayModePropertiesKHR");
    pfnGetDisplayPlaneCapabilitiesKHR =
        (PFN_vkGetDisplayPlaneCapabilitiesKHR)
        vkGetInstanceProcAddr(instance, "vkGetDisplayPlaneCapabilitiesKHR");
    pfnGetDisplayPlaneSupportedDisplaysKHR =
        (PFN_vkGetDisplayPlaneSupportedDisplaysKHR)
        vkGetInstanceProcAddr(instance, "vkGetDisplayPlaneSupportedDisplaysKHR");
    pfnCreateDisplayPlaneSurfaceKHR =
        (PFN_vkCreateDisplayPlaneSurfaceKHR)
        vkGetInstanceProcAddr(instance, "vkCreateDisplayPlaneSurfaceKHR");

    // Get a list of displays on a physical device
    displayCount = 0;
    pfnGetPhysicalDeviceDisplayPropertiesKHR(physDevice, &amp;displayCount, NULL);

    pDisplayProps = (VkDisplayPropertiesKHR*)malloc(sizeof(VkDisplayPropertiesKHR) * displayCount);
    pfnGetPhysicalDeviceDisplayPropertiesKHR(physDevice, &amp;displayCount, pDisplayProps);

    // Get a list of display planes on a physical device
    planeCount = 0;
    pfnGetPhysicalDeviceDisplayPlanePropertiesKHR(physDevice, &amp;planeCount, NULL);
    pPlaneProps = (VkDisplayPlanePropertiesKHR*)malloc(sizeof(VkDisplayPlanePropertiesKHR) * planeCount);
    pfnGetPhysicalDeviceDisplayPlanePropertiesKHR(physDevice, &amp;planeCount, pPlaneProps);

    // Get the list of pModes each display supports
    for (i = 0; i &lt; displayCount; ++i)
    {
        VkDisplayKHR display = pDisplayProps[i].display;
        VkDisplayModePropertiesKHR* pModes;
        uint32_t modeCount;

        vkGetDisplayModePropertiesKHR(physDevice, display, &amp;modeCount, NULL);

        pModes = (VkDisplayModePropertiesKHR*)malloc(sizeof(VkDisplayModePropertiesKHR) * modeCount);
        vkGetDisplayModePropertiesKHR(physDevice, display, &amp;modeCount, pModes);

        myMode = VK_NULL_HANDLE;
        for (j = 0; j &lt; modeCount; ++j)
        {
            const VkDisplayModePropertiesKHR* mode = &amp;pModes[i];

            if (ModeMatchesMyCriteria(mode))
            {
                myMode = mode-&gt;displayMode;
                break;
            }
        }

        free(pModes);

        // If there are no useable pModes found then check the next display.
        if (myMode == VK_NULL_HANDLE)
            continue;

        // Find a plane that matches these criteria, in order of preference:
        // -Is compatible with the chosen display + mode.
        // -Isn't currently bound to another display.
        // -Supports per-pixel alpha, if possible.
        for (j = 0; j &lt; planeCount; ++j)
        {
            uint32_t supportedCount = 0;
            VkDisplayKHR* pSupportedDisplays;
            VkDisplayPlaneCapabilitiesKHR planeCaps;
            // See if the plane is compatible with the current display.
            pfnGetDisplayPlaneSupportedDisplaysKHR(physDevice, j, &amp;supportedCount, NULL);

            // Plane doesn't support any displays.  This might happen on a card
            // that has a fixed mapping between planes and connectors when no
            // displays are currently attached to this plane's conector, for
            // example.
            if (supportedCount == 0)
                continue;

            pSupportedDisplays = (VkDisplayKHR*)malloc(sizeof(VkDisplayKHR) * supportedCount);
            pfnGetDisplayPlaneSupportedDisplaysKHR(physDevice, j, &amp;supportedCount, pSupportedDisplays);

            for (k = 0; k &lt; supportedCount; ++k)
                if (pSupportedDisplays[k] == display) {
                    // If no supported plane has yet been found, this is
                    // currently the best available plane.
                    if (bestPlane == UINT32_MAX)
                        bestPlane = j;
                    break;
                }

            // If the plane can't be used with the chosen display, keep looking.
            // Each display must have at least one compatible plane.
            if (k == supportedCount)
                continue;

            // If the plane passed the above test and is currently bound to the
            // desired display, or is not in use, it is the best plane found so
            // far.
            if ((pPlaneProps[j].currentDisplay == VK_NULL_HANDLE) &amp;&amp;
                (pPlaneProps[j].currentDisplay == display))
                bestPlane = j;
            else
                continue;

            pfnGetDisplayPlaneCapabilitiesKHR(physDevice, myMode, j, &amp;planeCaps);

            // Prefer a plane that supports per-pixel alpha.
            if (planeCaps.supportedAlpha &amp; VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR)
            {
                // This is the perfect plane for the given criteria.  Use it.
                bestPlane = j;
                alphaMode = VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR;
                break;
            }
        }
    }

    free(pDisplayProps);

    if (myDisplay == VK_NULL_HANDLE || myMode == VK_NULL_HANDLE) {
        // No suitable display + mode could be found.  Abort.
        abort();
    } else {
        // Success.  Create a VkSurfaceKHR object for this plane.
        const VkDisplaySurfaceCreateInfoKHR createInfo =
        {
            VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR,  // sType
            NULL,                                               // pNext
            0,                                                  // flags
            myMode,                                             // displayMode
            bestPlane,                                          // planeIndex
            pPlaneProps[bestPlane].currentStackIndex,           // planeStackIndex
            VK_SURFACE_TRANSFORM_IDENTITY_KHR,                  // transform
            1.0f,                                               // globalAlpha
            alphaMode,                                          // alphaMode
            ...
        }

        pfnCreateDisplayPlaneSurfaceKHR(instance, &amp;createInfo, NULL, &amp;surface);
    }</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_version_history_4"></a>F.4.8. Version History</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">
Revision 1, 2015-02-24 (James Jones)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Initial draft
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 2, 2015-03-12 (Norbert Nopper)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Added overlay enumeration for a display.
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 3, 2015-03-17 (Norbert Nopper)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Fixed typos and namings as discussed in Bugzilla.
</li><li class="listitem">
Reordered and grouped functions.
</li><li class="listitem">
Added functions to query count of display, mode and overlay.
</li><li class="listitem">
Added native display handle, which is maybe needed on some platforms to create a native Window.
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 4, 2015-03-18 (Norbert Nopper)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Removed primary and virtualPostion members (see comment of James Jones in Bugzilla).
</li><li class="listitem">
Added native overlay handle to info structure.
</li><li class="listitem">
Replaced , with ; in struct.
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 6, 2015-03-18 (Daniel Rakos)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Added WSI extension suffix to all items.
</li><li class="listitem">
Made the whole API more "Vulkanish".
</li><li class="listitem">
Replaced all functions with a single vkGetDisplayInfoKHR function to better match the rest of the API.
</li><li class="listitem">
Made the display, display mode, and overlay objects be first class objects, not subclasses of VkBaseObject as they don’t support the common functions anyways.
</li><li class="listitem">
Renamed *Info structures to *Properties.
</li><li class="listitem">
Removed overlayIndex field from VkOverlayProperties as there is an implicit index already as a result of moving to a "Vulkanish" API.
</li><li class="listitem">
Displays aren’t get through device, but through physical GPU to match the rest of the Vulkan API. Also this is something ISVs explicitly requested.
</li><li class="listitem">
Added issue (6) and (7).
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 7, 2015-03-25 (James Jones)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Added an issues section
</li><li class="listitem">
Added rotation and mirroring flags
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 8, 2015-03-25 (James Jones)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Combined the duplicate issues sections introduced in last change.
</li><li class="listitem">
Added proposed resolutions to several issues.
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 9, 2015-04-01 (Daniel Rakos)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Rebased extension against Vulkan 0.82.0
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 10, 2015-04-01 (James Jones)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Added issues (10) and (11).
</li><li class="listitem">
Added more straw-man issue resolutions, and cleaned up the
     proposed resolution for issue (4).
</li><li class="listitem">
Updated the rotation and mirroring enums to have proper bitfield
     semantics.
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 11, 2015-04-15 (James Jones)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Added proposed resolution for issues (1) and (2).
</li><li class="listitem">
Added issues (12), (13), (14), and (15)
</li><li class="listitem">
Removed pNativeHandle field from overlay structure.
</li><li class="listitem">
Fixed small compilation errors in example code.
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 12, 2015-07-29 (James Jones)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Rewrote the guts of the extension against the latest WSI swapchain
     specifications and the latest Vulkan API.
</li><li class="listitem">
Address overlay planes by their index rather than an object handle
     and refer to them as "planes" rather than "overlays" to make it
     slightly clearer that even a display with no "overlays" still has at
     least one base "plane" that images can be displayed on.
</li><li class="listitem">
Updated most of the issues.
</li><li class="listitem">
Added an "extension type" section to the specification header.
</li><li class="listitem">
Re-used the VK_EXT_KHR_surface surface transform enumerations rather
     than redefining them here.
</li><li class="listitem">
Updated the example code to use the new semantics.
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 13, 2015-08-21 (Ian Elliott)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Renamed this extension and all of its enumerations, types, functions,
     etc.  This makes it compliant with the proposed standard for Vulkan
     extensions.
</li><li class="listitem">
Switched from "revision" to "version", including use of the
     VK_MAKE_VERSION macro in the header file.
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 14, 2015-09-01 (James Jones)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Restore single-field revision number.
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 15, 2015-09-08 (James Jones)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Added alpha flags enum.
</li><li class="listitem">
Added premultiplied alpha support.
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 16, 2015-09-08 (James Jones)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Added description section to the spec.
</li><li class="listitem">
Added issues 16 - 18.
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 17, 2015-10-02 (James Jones)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Planes are now a property of the entire device rather than individual
     displays.  This allows planes to be moved between multiple displays
     on devices that support it.
</li><li class="listitem">
Added a function to create a VkSurfaceKHR object describing a display
     plane and mode to align with the new per-platform surface creation
     conventions.
</li><li class="listitem">
Removed detailed mode timing data.  It was agreed that the mode
     extents and refresh rate are sufficient for current use cases.  Other
     information could be added back2 in as an extension if it is needed in
     the future.
</li><li class="listitem">
Added support for smart/persistent/buffered display devices.
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 18, 2015-10-26 (Ian Elliott)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Renamed from VK_EXT_KHR_display to VK_KHR_display.
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 19, 2015-11-02 (James Jones)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Updataed example code to match revision 17 changes.
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 20, 2015-11-03 (Daniel Rakos)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Added allocation callbacks to creation functions.
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 21, 2015-11-10 (Jesse Hall)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Added VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR, and use
     VkDisplayPlaneAlphaFlagBitsKHR for VkDisplayPlanePropertiesKHR::alphaMode
     instead of VkDisplayPlaneAlphaFlagsKHR, since it only represents one mode.
</li><li class="listitem">
Added reserved flags bitfield to VkDisplayPlanePropertiesKHR.
</li><li class="listitem">
Use VkSurfaceTransformFlagBitsKHR instead of obsolete
     VkSurfaceTransformKHR.
</li><li class="listitem">
Renamed vkGetDisplayPlaneSupportedDisplaysKHR parameters for clarity.
</li></ul></div></li><li class="listitem"><p class="simpara">
Revision 22, 2015-12-18 (James Jones)
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
Added missing "planeIndex" parameter to
     vkGetDisplayPlaneSupportedDisplaysKHR()
</li></ul></div></li></ul></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="apfs03.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><td width="20%" align="center"><a accesskey="u" href="apf.html"><img src="images/icons/up.png" alt="Up" /></a></td><td width="40%" align="right"> <a accesskey="n" href="apfs05.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/icons/home.png" alt="Home" /></a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>